{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the EuXFEL Lattice OCELOT Model Documentation","text":""},{"location":"#installation","title":"Installation","text":"<p>Clone the repository and install the package using pip:</p> <pre><code>git clone git@github.com:ocelot-collab/EuXFEL-Lattice.git\ncd EuXFEL-Lattice\npip install .\n</code></pre> <p>Optionally you can install in editable mode:</p> <pre><code>pip install --editable .\n</code></pre> <p>This is necessary if you wish to update the repository model by converting from a component list.</p>"},{"location":"#command-line-interface","title":"Command Line Interface","text":"<p>The package comes with a simple command line interface (CLI) for some basic operations.  The CLI can accessed with the <code>euxfel</code> command once the package has been installed:</p> <pre><code>$ euxfel --help\nUsage: euxfel [OPTIONS] COMMAND [ARGS]...\n\n  Main entrypoint.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  compare      Check the OCELOT optics against the Component List\n  convert      Convert Component List files to a set of Python modules\n  plot         Plot the full optics from the cathode to one of the dumps\n  subsequence  Plot the OCELOT model'\n</code></pre> <p>You are unlikely to need to do any conversions yourself, but it may be useful to inspect the optics in different parts of the machine.  See</p>"},{"location":"#start-to-end-simulations","title":"Start to End Simulations","text":"<p>The top-level directory containing all the scripts for running the start to end simulations is <code>s2e_scripts</code>:</p> <pre><code>$ cd s2e_scripts\n$ ls -1\ninj_hires_optics_track.py\ninjector_hires_optics.py\ns2e_up_to_B2D.py\ns2e_up_to_I1D_screen.py\ns2e_up_to_SA1.py\ns2e_up_to_SA2.py\ns2e_up_to_SA3.py\ns2e_up_to_switchyard_op_values_SASE1_rf_par.py\ns2e_up_to_switchyard_op_values_SASE2_rf_par.py\ns2e_up_to_switchyard_operational_values.py\ns2e_up_to_switchyard.py\n</code></pre> <p>Each one of these corresponds to a simulation from s = 3.2m after the cathode to a specific point downstream.  The compression settings used are standard ones corresponding to a final peak current of (5-6)kA.</p>"},{"location":"#optics","title":"Optics","text":""},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"AUTHORS/","title":"Authors","text":""},{"location":"AUTHORS/#in-alphabetical-order","title":"In Alphabetical Order","text":"<ul> <li>Sergey Tomin</li> <li>Bianca Veglia</li> <li>Stuart Walker</li> <li>Igor Zagorodnov</li> </ul>"},{"location":"conversion/","title":"Conversion","text":""},{"location":"conversion/#how-to-run-the-conversion-now","title":"How to Run the Conversion Now","text":"<p>Currently the OCELOT Python EuXFEL sequences are generated from the \"Component List\", an Excel spreadsheet generated internally by the group leader as the \"single source of truth\" for what actually is in the tunnel.  These files can be found here.</p> <p>Clone the repository and install the Python package.  Put the component list you want to convert in <code>src/euxfel/longlists</code>, or use one that is already there.  The converter will look for a file called <code>conversion-config.yaml</code> to drive the entire conversion process. Either use the existing one, make a new one, or make a symlink with the name <code>conversion-config.yaml</code> that points to one of the explicitly named (i.e. dated) yaml files. Look at one of the other conversion yaml files for guidance on how to write your own for a given component list.  Further details on the makeup of these conversion-config.yaml files is follows here.</p> <pre><code>$ euxfel convert\n</code></pre> <p>This will run, and the output will automatically be written to <code>src/euxfel/subsequences/</code>.</p>"},{"location":"conversion/#changing-ocelot-lattice-versions","title":"Changing OCELOT Lattice Versions","text":"<p>If you want to use a different version of the lattice, then the easiest way is to check out a different tagged release. Always use the latest version for a given model type:</p> <p>To use v0.2 (at the time of writing the latest version) of the July 2024 model:</p> <pre><code>$ git checkout 0.2.0+componentlist.20240704\n</code></pre> <p>To use v0.2 of the January 2026 model:</p> <pre><code>$ git checkout 0.2.0+componentlist.20260121\n</code></pre> <p>API changes should be separate from lattice versions and the two packages should be functionally identical except for the lattice files.</p>"},{"location":"conversion/#conversion-configuration","title":"Conversion Configuration","text":"<p>The conversion should be as transparent as possible, and absolutely no hand edits of the output Python modules should be necessary.  To this end, the configuration is fully described in the file conversion-config.yaml.  I'll try to explain some of the sections of this config file here.</p> <p>The filename is chosen as:</p> <pre><code>component_list: component_list_2026.01.21.xls\n</code></pre>"},{"location":"conversion/#writer","title":"Writer","text":"<p>Configure the writing of the output Python files with the <code>writer</code> heading.  Currently the only setting is <code>writer_types_power_supplies</code> with which you can configure which element types have their power supply IDs written.</p> <pre><code>writer:\n  write_types_power_supplies: [\"Quadrupole\", \"Sextupole\", \"Octupole\", \"Cavity\", \"RBend\", \"SBend\"]\n</code></pre>"},{"location":"conversion/#rows","title":"Rows","text":"<p>Row based edits with <code>rows</code> header.  Subheaders include <code>skip</code> for skipping certain elements altogether based on TYPE, CLASS, GROUP and NAME1 from the component list.  <code>edit</code> provides for a crude update to the component list row dictionary immediately prior to generating the OCELOT component.  The below skips all of the listed <code>TYPE</code>, <code>CLASS</code> and <code>GROUP</code>, as well as setting all \"CAX\", \"CAY\", \"CBX\" and \"CBY\" lengths to zero (these are the aircoils, which in pairs are directly on top of each other in the component list, yet with non-zero length, which is not permitted).</p> <pre><code>rows:\n  skip:\n    TYPE: [\"BENDMARK\", \"RF\", \"CTBI\", \"CUX\"]\n    CLASS: [\"CRYO\", \"UNDPLACEH\"]\n    GROUP: [\"CRYO\",\n            \"VACUUM\",\n            \"MOVER\",\n            \"PHOTON\",\n            \"DUMP\"]\n    NAME1: []\n\n  edit:\n    TYPE:\n      CAX: { LENGTH: 0.0 }\n      CAY: { LENGTH: 0.0 }\n      CBX: { LENGTH: 0.0 }\n      CBY: { LENGTH: 0.0 }\n    CLASS: {}\n    GROUP: {}\n</code></pre>"},{"location":"conversion/#sections","title":"Sections","text":"<p>With <code>sections</code> header the modules themselves are defined.  The basic definition requires a name, for example I1D (which would then become i1d.py), a sheet name from the Component List to use (not LONGLIST, in order to ensure the correct extraction are powered for each path through the machine), and two marker names from the Component List, one for start and one for stop.</p>"},{"location":"conversion/#new-markers","title":"New Markers","text":"<p>For the effective inclusion of physics processes, it's necessary to introduce additional markers.  For example, the OCELOT simulation starts at 3.2m after the cathode, but there is no marker at this point in the component list.  These can all be added with the <code>new_markers</code> section.  For example, in I1:</p> <pre><code>sections:\n  I1:\n    [...]\n    new_markers:\n      stop_astra: { s: 3.2 }\n      start_ocelot: { s: 3.2 }\n      lh_start: { reference: U74.49.I1, adjacent: before }\n      lh_stop: { reference: U74.49.I1, adjacent: after }\n      DUMP.CSR.START: { s: 38.789005 }\n</code></pre> <p>This introduces two markers at 3.2m and one at 38.789m (just befor the I1D dump dipole).</p> <p>\u26a0\ufe0f Warning:: It is up to the user to ensure that these inserted markers are not placed inside of other elements!  There is no checking done on this and it may fail cryptically.</p> <p>Additionaly, the laser heater undulator <code>U74.49.I1</code> is wrapped with two markers, one immediately <code>before</code> and one immediately <code>after</code> in order to attach the laser heater process correctly.</p>"},{"location":"conversion/#additional-element-properties","title":"Additional Element Properties","text":"<p>In I1D it is necessary to introduce two additional element properties which are missing in the component list.  Firstly, the TDS must be rotated by 90 degrees, and the undulator must be closed.  This is done with the <code>extras</code> section of the section definition:</p> <pre><code>sections:\n  I1:\n    [...]\n    extras:\n      TDSA.52.I1:\n        tilt: 1.570796327\n      U74.49.I1:\n        Kx: 1.294\n        Ky: 0\n</code></pre>"},{"location":"conversion/#rematching-at-conversion-time","title":"Rematching at Conversion Time","text":"<p>Finally, due to the focusing from the undulator, when the undulator is closed, the matching from the cathode will now be wrong.  We need to rematch whilst converting to calculate the correct quadrupole strengths.  The snippet below states to rematch at the given market with respect to the reference optics, using hte listed quadrupoles.</p> <pre><code>sections:\n  I1:\n    [...]\n    matching:\n      marker: MATCH.52.I1\n      quadrupoles:\n        - Q.37.I1\n        - Q.38.I1\n        - QI.46.I1\n        - QI.47.I1\n        - QI.50.I1\n</code></pre>"},{"location":"conversion/#inserting-additional-elements","title":"Inserting Additional Elements","text":"<p>The so-called XY-quadrupoles are not in the component list, but they are needed in order to get the correct optics.  For example for the TL section, the XY-quadrupole is approximated with 190 slices of a horizontal combined function magnet and 10 slices of a vertical combined function magnet, interleaved with each other.  The position is set with reference to the previous dipole, set to start 0.4724m past the end of BZ.1980.TLD.</p> <pre><code>sections:\n  [...]\n  Tl2TLD:\n    [...]\n    new_elements:\n      QK.1982.TL:\n        position: { reference: MBZ.1980d.TLD, s: 0.4724 }\n        type: SlicedElement\n        expression: \"(19 * [xslice1982] + [yslice1982]) * 10\"\n        elements:\n          xslice1982:\n            type: RBend\n            l: 0.005276\n            angle: 1.180477777265855e-05\n            k1: 0.090359600075815\n          yslice1982:\n            type: RBend\n            l: 0.005276\n            angle: -7.780804909999998e-05\n            k1: -0.090359600075815\n            tilt: 1.570796327\n</code></pre> <p>\u26a0\ufe0f Warning: the named refrence element must have no other elements between it and the newly inserted element.  Otherwise it will most likely fail and it will fail mysteriously, most likely with cryptic complains about negative drift lengths!  I never added special checks on this.</p> <p>Currently no other element types besides the <code>SlicedElement</code> may be inserted into the lattice at conversion time.</p>"},{"location":"model-details/","title":"Model details","text":""},{"location":"model-details/#further-comments","title":"Further Comments","text":""},{"location":"model-details/#important","title":"IMPORTANT","text":"<p>In the distribution section two beams (straight and kicked) are going through the same quadrupoles and hence see the different magnetic fields:           \u2022 straight beam only quadrupole component           \u2022 kicked beam - main quadrupole component and additional dipole components. The model of the magnets for the kicked beams needs to take into account these components.</p> <p>Specifically, the extraction to T5D and the extraction to TLD lines have offsets on bot horizontal and vertical planes. The magnet needs to be split into N slices: sequence of horizontal and vertical combine function magnets. More details about the modelling of the magnetic elements for the kicked beams can be found in  this presentation , courtesy of Nina Golubeva.</p>"},{"location":"model-details/#note","title":"NOTE:","text":"<ol> <li>LH undulator.</li> <li>The length of 0.74 m is the iron length.</li> <li> <p>The model of natural focusing has been created using measured field profiles which are longer (0.918 m).</p> </li> <li> <p>Natural focusing</p> </li> <li>In the design optics the natural undulator focusing is not taking into account (drift).</li> <li>To take into account the natural focusing you have      to set up the beam parameters (energy) and the undulator setup (gap).      The natural focusing effect (matrices) is then calculated using analytical formulas. One example can be found in the file:      SET_LHund_closed_130MeV_42mm.txm</li> <li> <p>If the natural focusing is taken into account, it needs to rematch the beam in the injector.</p> </li> <li> <p>Coupler kick in all RF cavities are off.</p> </li> </ol>"},{"location":"optics/","title":"Optics","text":""},{"location":"optics/#optics-in-plain-python","title":"Optics in Plain Python","text":"<p>You can of course use the euxfel package in Python as a normal library, for example to access the sequence from the cathode to I1D in Python:</p> <pre><code>import euxfel.sequences as sequences\nfrom ocelot import *\nfrom ocelot.gui.accelerator import *\nimport matplotlib.pyplot as plt\ntwiss0 = sequences.CATHODE_TWISS0\nmlat_i1d = MagneticLattice(sequences.cathode_to_i1d)\nmachine_twiss = twiss(mlat_i1d, twiss0)\n# Example of use with plain OCELOT:\nplot_opt_func(mlat_i1d, machine_twiss)\nplt.show()\n</code></pre> <p>In addition to <code>sequences.cathode_to_i1d</code>, there is also a <code>squences.cathode_to_</code> attribute for <code>b1d</code>, <code>b2d</code>, <code>tld</code>, <code>t4d</code> and <code>t5d</code>.</p>"}]}